#summary Simple Demo of using ZK Spreadsheet with XPage

=UNDER CONSTRUCTION=

In this demo, we have two input fields that bind to a controller (SBean)'s {{{cell}}} and {{{value}}} attributes. It also has two buttons to get and set values in Spreadsheet.

== Create an XPage ==
 # Create an Xpage in your database
 # Drag two inputText boxes(named inputCell and inputValue) to the Xpage. Change the layout. Bind the values to #{sbean.cell} & #{sbean.value} respectively. 
 # Add two buttons(named getBtn and setBtn) to the Xpage.
 # Add action to getBtn button by invoking {{{sbean.doGet()}}} and set a partial update ID to inputValue.
 # Add action to setBtn button by invoking {{{sbean.doSet()}}} and set a partial update ID to setBtn. (Note: You don't have to set a partial update to the ZK component as this will be taken care of automatically. However if you didn't set any partial update IDs, the whole FORM will be refreshed. So it is suggested to set a partial ID to 'setBtn' element to save some effort).

Page Preview:<br/>http://zkxpage.googlecode.com/svn/trunk/docs/images/simpledemo_1.png 

The source code:
{{{
<?xml version="1.0" encoding="UTF-8"?>
<xp:view xmlns:xp="http://www.ibm.com/xsp/core"
	xmlns:zk="http://www.zkoss.org/xpage"
	xmlns:xp_1="http://www.ibm.com/xsp/coreex">

	Cell:
	<xp:inputText id="inputCell" value="#{sbean.cell}"></xp:inputText>
	,Value:
	<xp:inputText id="inputValue" value="#{sbean.value}"></xp:inputText>
	<xp:br></xp:br>

	<xp:button value="Get" id="getBtn">
		<xp:eventHandler event="onclick" submit="true" refreshMode="partial" refreshId="inputValue">
			<xp:this.action>
				<xp:executeScript script="#{javascript:sbean.doGet()}"></xp:executeScript>
			</xp:this.action>
		</xp:eventHandler>
	</xp:button>
	<xp:button value="Set" id="setBtn">
		<xp:eventHandler event="onclick" submit="true" refreshMode="partial" refreshId="setBtn">
			<xp:this.action>
				<xp:executeScript script="#{javascript:sbean.doSet()}"></xp:executeScript>
			</xp:this.action>
		</xp:eventHandler>
	</xp:button>
</xp:view>

}}}
== Add spreadsheet component ==
 # Continue above example, drag a spreadsheet from Controls view (in ZK category) to the page.
 # Name it myspreadsheet, binding to {{{zkComponentBinding['spreadsheet1']}}}, set the width and height to 600px,400px
Now the xpage source look looks like this
{{{
<?xml version="1.0" encoding="UTF-8"?>
<xp:view xmlns:xp="http://www.ibm.com/xsp/core"
	xmlns:zk="http://www.zkoss.org/xpage"
	xmlns:xp_1="http://www.ibm.com/xsp/coreex">

	Cell:
	<xp:inputText id="inputCell" value="#{sbean.cell}"></xp:inputText>
	,Value:
	<xp:inputText id="inputValue" value="#{sbean.value}"></xp:inputText>
	<xp:br></xp:br>

	<xp:button value="Get" id="getBtn">
		<xp:eventHandler event="onclick" submit="true" refreshMode="partial" refreshId="inputValue">
			<xp:this.action>
				<xp:executeScript script="#{javascript:sbean.doGet()}"></xp:executeScript>
			</xp:this.action>
		</xp:eventHandler>
	</xp:button>
	<xp:button value="Set" id="setBtn">
		<xp:eventHandler event="onclick" submit="true" refreshMode="partial" refreshId="setBtn">
			<xp:this.action>
				<xp:executeScript script="#{javascript:sbean.doSet()}"></xp:executeScript>
			</xp:this.action>
		</xp:eventHandler>
	</xp:button>
	<xp:br></xp:br>
	<zk:spreadsheet id="myspreadsheet" height="400px" width="600px">
		<zk:this.binding><![CDATA[#{zkComponentBinding['spreadsheet1']}]]></zk:this.binding>
	</zk:spreadsheet>	
</xp:view>
}}}

You page preview should be like : <br/>
Page preview<br/>http://zkxpage.googlecode.com/svn/trunk/docs/images/simpledemo_2.png 

== Write the controller (SBean) ==
In this demo, we use general JSF Backing Bean to control the xpage. here is the steps.
 # Create a Java class(test.SBean) in one of the source folder (except {{{Local}}}, if you don't have other source folder, please create a new source folder).
 # add 2 member field {{{cell}}}, {{{value}}} and the getter/setter. The xpage will binding to these member fields ( remember what we have binded in xpage?, the {{{#{sbean.cell},#{sbean.value}}}}).
 # add 2 method {{{doGet}}}, {{{doSet}}}. Implement the logic to get and set the spreadsheet value depends on selected cell. When clicking the button, these 2 methods will be called. 
Following is the code looks like
{{{
package test;

import org.zkoss.poi.ss.usermodel.RichTextString;
import org.zkoss.xpage.core.bean.ComponentBinding;
import org.zkoss.xpage.core.component.Action;
import org.zkoss.xpage.core.component.ZulBridgeBase;
import org.zkoss.zss.model.FormatText;
import org.zkoss.zss.model.Range;
import org.zkoss.zss.model.Ranges;
public class SBean {

	String cell = "A1";
	String value;

	public String getCell() {
		return cell;
	}
	public void setCell(String cell) {
		this.cell = cell;
	}
	public String getValue() {
		return value;
	}
	public void setValue(String value) {
		this.value = value;
	}

	public void doSet(){
		//get the binding bridge back, and execute the action
		ComponentBinding.getBridge("spreadsheet1").execute(new Action(){
			public void doAction(ZulBridgeBase bridge) {
				//get the spreadsheet
				org.zkoss.zss.ui.Spreadsheet ss = (org.zkoss.zss.ui.Spreadsheet)bridge.getComponent();
				//use spreadsheet api to get value
				final Range range = Ranges.range(ss.getSelectedSheet(), cell);
				range.setEditText(value);
				
			}});
	}
	
	public void doGet(){
		//get the binding bridge back, and execute the action
		ComponentBinding.getBridge("spreadsheet1").execute(new Action(){
			public void doAction(ZulBridgeBase bridge) {
				//get the spreadsheet
				org.zkoss.zss.ui.Spreadsheet ss = (org.zkoss.zss.ui.Spreadsheet)bridge.getComponent();
				//use spreadsheet api to get value
				Range range = Ranges.range(ss.getSelectedSheet(), cell);
				FormatText ft = range.getFormatText();
				if (ft != null && ft.isCellFormatResult()) {
					value = ft.getCellFormatResult().text;
				} else {
					final RichTextString rstr = range == null ? null : range
							.getRichEditText();
					value = rstr != null ? rstr.getString() : "";
				}
			}});
	}
}

}}}

Ok, now You have to do the final step.
 # Edit file {{{WebContent/WEB-INF/faces-config.xml}}}, add a sbean which uses the Java class you just created.
{{{
<?xml version="1.0" encoding="UTF-8"?>
<faces-config>
  <managed-bean>
    <managed-bean-name>sbean</managed-bean-name>
    <managed-bean-class>test.SBean</managed-bean-class>
    <managed-bean-scope>request</managed-bean-scope>
  </managed-bean>
  <!--AUTOGEN-START-BUILDER: Automatically generated by IBM Lotus Domino Designer. Do not modify.-->
  <!--AUTOGEN-END-BUILDER: End of automatically generated section-->
</faces-config>
}}}
== Test and Run ==
Open browser, link to the page , ex http://localhost/demo.nsf/spreadsheet.xsp, and try following simple test steps.
 # Click at spreadsheet, edit cell A1, set the value to {{{ABCD}}}, in inputTexts, edit the cell to {{{A1}}}, click the Get button. you will see the value become {{{ABCD}}}
 # In inputTexts, edit the cell to {{{A2}}}, value to {{{1234}}}, click the Set button. you will see the cell A2 of spreadsheet become to {{{1234}}}
 # Click at spreadsheet, edit cell B1, set the value to a formula {{{=SUM(C1:C3)}}}, you will see B1 value become 0, that is because C1 to C3 is empty. Now, set the cell C1 to C3 by editing spreadsheet or inputText & Set button, you will see B2 will always the sum value of C1 to C3.

http://zkxpage.googlecode.com/svn/trunk/docs/images/simpledemo_3.png 